// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/atom-apps/dictionary/database/models"
)

func newDictionaryGroupItem(db *gorm.DB, opts ...gen.DOOption) dictionaryGroupItem {
	_dictionaryGroupItem := dictionaryGroupItem{}

	_dictionaryGroupItem.dictionaryGroupItemDo.UseDB(db, opts...)
	_dictionaryGroupItem.dictionaryGroupItemDo.UseModel(&models.DictionaryGroupItem{})

	tableName := _dictionaryGroupItem.dictionaryGroupItemDo.TableName()
	_dictionaryGroupItem.ALL = field.NewAsterisk(tableName)
	_dictionaryGroupItem.ID = field.NewInt64(tableName, "id")
	_dictionaryGroupItem.CreatedAt = field.NewTime(tableName, "created_at")
	_dictionaryGroupItem.UpdatedAt = field.NewTime(tableName, "updated_at")
	_dictionaryGroupItem.DeletedAt = field.NewField(tableName, "deleted_at")
	_dictionaryGroupItem.DictionaryGroupID = field.NewInt64(tableName, "dictionary_group_id")
	_dictionaryGroupItem.Value = field.NewString(tableName, "value")
	_dictionaryGroupItem.Order = field.NewInt64(tableName, "order")

	_dictionaryGroupItem.fillFieldMap()

	return _dictionaryGroupItem
}

type dictionaryGroupItem struct {
	dictionaryGroupItemDo dictionaryGroupItemDo

	ALL               field.Asterisk
	ID                field.Int64
	CreatedAt         field.Time
	UpdatedAt         field.Time
	DeletedAt         field.Field
	DictionaryGroupID field.Int64
	Value             field.String // 字典项值
	Order             field.Int64  // 排序

	fieldMap map[string]field.Expr
}

func (d dictionaryGroupItem) Table(newTableName string) *dictionaryGroupItem {
	d.dictionaryGroupItemDo.UseTable(newTableName)
	return d.updateTableName(newTableName)
}

func (d dictionaryGroupItem) As(alias string) *dictionaryGroupItem {
	d.dictionaryGroupItemDo.DO = *(d.dictionaryGroupItemDo.As(alias).(*gen.DO))
	return d.updateTableName(alias)
}

func (d *dictionaryGroupItem) updateTableName(table string) *dictionaryGroupItem {
	d.ALL = field.NewAsterisk(table)
	d.ID = field.NewInt64(table, "id")
	d.CreatedAt = field.NewTime(table, "created_at")
	d.UpdatedAt = field.NewTime(table, "updated_at")
	d.DeletedAt = field.NewField(table, "deleted_at")
	d.DictionaryGroupID = field.NewInt64(table, "dictionary_group_id")
	d.Value = field.NewString(table, "value")
	d.Order = field.NewInt64(table, "order")

	d.fillFieldMap()

	return d
}

func (d *dictionaryGroupItem) WithContext(ctx context.Context) IDictionaryGroupItemDo {
	return d.dictionaryGroupItemDo.WithContext(ctx)
}

func (d dictionaryGroupItem) TableName() string { return d.dictionaryGroupItemDo.TableName() }

func (d dictionaryGroupItem) Alias() string { return d.dictionaryGroupItemDo.Alias() }

func (d dictionaryGroupItem) Columns(cols ...field.Expr) gen.Columns {
	return d.dictionaryGroupItemDo.Columns(cols...)
}

func (d *dictionaryGroupItem) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := d.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (d *dictionaryGroupItem) fillFieldMap() {
	d.fieldMap = make(map[string]field.Expr, 7)
	d.fieldMap["id"] = d.ID
	d.fieldMap["created_at"] = d.CreatedAt
	d.fieldMap["updated_at"] = d.UpdatedAt
	d.fieldMap["deleted_at"] = d.DeletedAt
	d.fieldMap["dictionary_group_id"] = d.DictionaryGroupID
	d.fieldMap["value"] = d.Value
	d.fieldMap["order"] = d.Order
}

func (d dictionaryGroupItem) clone(db *gorm.DB) dictionaryGroupItem {
	d.dictionaryGroupItemDo.ReplaceConnPool(db.Statement.ConnPool)
	return d
}

func (d dictionaryGroupItem) replaceDB(db *gorm.DB) dictionaryGroupItem {
	d.dictionaryGroupItemDo.ReplaceDB(db)
	return d
}

type dictionaryGroupItemDo struct{ gen.DO }

type IDictionaryGroupItemDo interface {
	gen.SubQuery
	Debug() IDictionaryGroupItemDo
	WithContext(ctx context.Context) IDictionaryGroupItemDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IDictionaryGroupItemDo
	WriteDB() IDictionaryGroupItemDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IDictionaryGroupItemDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IDictionaryGroupItemDo
	Not(conds ...gen.Condition) IDictionaryGroupItemDo
	Or(conds ...gen.Condition) IDictionaryGroupItemDo
	Select(conds ...field.Expr) IDictionaryGroupItemDo
	Where(conds ...gen.Condition) IDictionaryGroupItemDo
	Order(conds ...field.Expr) IDictionaryGroupItemDo
	Distinct(cols ...field.Expr) IDictionaryGroupItemDo
	Omit(cols ...field.Expr) IDictionaryGroupItemDo
	Join(table schema.Tabler, on ...field.Expr) IDictionaryGroupItemDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IDictionaryGroupItemDo
	RightJoin(table schema.Tabler, on ...field.Expr) IDictionaryGroupItemDo
	Group(cols ...field.Expr) IDictionaryGroupItemDo
	Having(conds ...gen.Condition) IDictionaryGroupItemDo
	Limit(limit int) IDictionaryGroupItemDo
	Offset(offset int) IDictionaryGroupItemDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IDictionaryGroupItemDo
	Unscoped() IDictionaryGroupItemDo
	Create(values ...*models.DictionaryGroupItem) error
	CreateInBatches(values []*models.DictionaryGroupItem, batchSize int) error
	Save(values ...*models.DictionaryGroupItem) error
	First() (*models.DictionaryGroupItem, error)
	Take() (*models.DictionaryGroupItem, error)
	Last() (*models.DictionaryGroupItem, error)
	Find() ([]*models.DictionaryGroupItem, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.DictionaryGroupItem, err error)
	FindInBatches(result *[]*models.DictionaryGroupItem, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*models.DictionaryGroupItem) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IDictionaryGroupItemDo
	Assign(attrs ...field.AssignExpr) IDictionaryGroupItemDo
	Joins(fields ...field.RelationField) IDictionaryGroupItemDo
	Preload(fields ...field.RelationField) IDictionaryGroupItemDo
	FirstOrInit() (*models.DictionaryGroupItem, error)
	FirstOrCreate() (*models.DictionaryGroupItem, error)
	FindByPage(offset int, limit int) (result []*models.DictionaryGroupItem, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IDictionaryGroupItemDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (d dictionaryGroupItemDo) Debug() IDictionaryGroupItemDo {
	return d.withDO(d.DO.Debug())
}

func (d dictionaryGroupItemDo) WithContext(ctx context.Context) IDictionaryGroupItemDo {
	return d.withDO(d.DO.WithContext(ctx))
}

func (d dictionaryGroupItemDo) ReadDB() IDictionaryGroupItemDo {
	return d.Clauses(dbresolver.Read)
}

func (d dictionaryGroupItemDo) WriteDB() IDictionaryGroupItemDo {
	return d.Clauses(dbresolver.Write)
}

func (d dictionaryGroupItemDo) Session(config *gorm.Session) IDictionaryGroupItemDo {
	return d.withDO(d.DO.Session(config))
}

func (d dictionaryGroupItemDo) Clauses(conds ...clause.Expression) IDictionaryGroupItemDo {
	return d.withDO(d.DO.Clauses(conds...))
}

func (d dictionaryGroupItemDo) Returning(value interface{}, columns ...string) IDictionaryGroupItemDo {
	return d.withDO(d.DO.Returning(value, columns...))
}

func (d dictionaryGroupItemDo) Not(conds ...gen.Condition) IDictionaryGroupItemDo {
	return d.withDO(d.DO.Not(conds...))
}

func (d dictionaryGroupItemDo) Or(conds ...gen.Condition) IDictionaryGroupItemDo {
	return d.withDO(d.DO.Or(conds...))
}

func (d dictionaryGroupItemDo) Select(conds ...field.Expr) IDictionaryGroupItemDo {
	return d.withDO(d.DO.Select(conds...))
}

func (d dictionaryGroupItemDo) Where(conds ...gen.Condition) IDictionaryGroupItemDo {
	return d.withDO(d.DO.Where(conds...))
}

func (d dictionaryGroupItemDo) Order(conds ...field.Expr) IDictionaryGroupItemDo {
	return d.withDO(d.DO.Order(conds...))
}

func (d dictionaryGroupItemDo) Distinct(cols ...field.Expr) IDictionaryGroupItemDo {
	return d.withDO(d.DO.Distinct(cols...))
}

func (d dictionaryGroupItemDo) Omit(cols ...field.Expr) IDictionaryGroupItemDo {
	return d.withDO(d.DO.Omit(cols...))
}

func (d dictionaryGroupItemDo) Join(table schema.Tabler, on ...field.Expr) IDictionaryGroupItemDo {
	return d.withDO(d.DO.Join(table, on...))
}

func (d dictionaryGroupItemDo) LeftJoin(table schema.Tabler, on ...field.Expr) IDictionaryGroupItemDo {
	return d.withDO(d.DO.LeftJoin(table, on...))
}

func (d dictionaryGroupItemDo) RightJoin(table schema.Tabler, on ...field.Expr) IDictionaryGroupItemDo {
	return d.withDO(d.DO.RightJoin(table, on...))
}

func (d dictionaryGroupItemDo) Group(cols ...field.Expr) IDictionaryGroupItemDo {
	return d.withDO(d.DO.Group(cols...))
}

func (d dictionaryGroupItemDo) Having(conds ...gen.Condition) IDictionaryGroupItemDo {
	return d.withDO(d.DO.Having(conds...))
}

func (d dictionaryGroupItemDo) Limit(limit int) IDictionaryGroupItemDo {
	return d.withDO(d.DO.Limit(limit))
}

func (d dictionaryGroupItemDo) Offset(offset int) IDictionaryGroupItemDo {
	return d.withDO(d.DO.Offset(offset))
}

func (d dictionaryGroupItemDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IDictionaryGroupItemDo {
	return d.withDO(d.DO.Scopes(funcs...))
}

func (d dictionaryGroupItemDo) Unscoped() IDictionaryGroupItemDo {
	return d.withDO(d.DO.Unscoped())
}

func (d dictionaryGroupItemDo) Create(values ...*models.DictionaryGroupItem) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Create(values)
}

func (d dictionaryGroupItemDo) CreateInBatches(values []*models.DictionaryGroupItem, batchSize int) error {
	return d.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (d dictionaryGroupItemDo) Save(values ...*models.DictionaryGroupItem) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Save(values)
}

func (d dictionaryGroupItemDo) First() (*models.DictionaryGroupItem, error) {
	if result, err := d.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*models.DictionaryGroupItem), nil
	}
}

func (d dictionaryGroupItemDo) Take() (*models.DictionaryGroupItem, error) {
	if result, err := d.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*models.DictionaryGroupItem), nil
	}
}

func (d dictionaryGroupItemDo) Last() (*models.DictionaryGroupItem, error) {
	if result, err := d.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*models.DictionaryGroupItem), nil
	}
}

func (d dictionaryGroupItemDo) Find() ([]*models.DictionaryGroupItem, error) {
	result, err := d.DO.Find()
	return result.([]*models.DictionaryGroupItem), err
}

func (d dictionaryGroupItemDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.DictionaryGroupItem, err error) {
	buf := make([]*models.DictionaryGroupItem, 0, batchSize)
	err = d.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (d dictionaryGroupItemDo) FindInBatches(result *[]*models.DictionaryGroupItem, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return d.DO.FindInBatches(result, batchSize, fc)
}

func (d dictionaryGroupItemDo) Attrs(attrs ...field.AssignExpr) IDictionaryGroupItemDo {
	return d.withDO(d.DO.Attrs(attrs...))
}

func (d dictionaryGroupItemDo) Assign(attrs ...field.AssignExpr) IDictionaryGroupItemDo {
	return d.withDO(d.DO.Assign(attrs...))
}

func (d dictionaryGroupItemDo) Joins(fields ...field.RelationField) IDictionaryGroupItemDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Joins(_f))
	}
	return &d
}

func (d dictionaryGroupItemDo) Preload(fields ...field.RelationField) IDictionaryGroupItemDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Preload(_f))
	}
	return &d
}

func (d dictionaryGroupItemDo) FirstOrInit() (*models.DictionaryGroupItem, error) {
	if result, err := d.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*models.DictionaryGroupItem), nil
	}
}

func (d dictionaryGroupItemDo) FirstOrCreate() (*models.DictionaryGroupItem, error) {
	if result, err := d.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*models.DictionaryGroupItem), nil
	}
}

func (d dictionaryGroupItemDo) FindByPage(offset int, limit int) (result []*models.DictionaryGroupItem, count int64, err error) {
	result, err = d.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = d.Offset(-1).Limit(-1).Count()
	return
}

func (d dictionaryGroupItemDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = d.Count()
	if err != nil {
		return
	}

	err = d.Offset(offset).Limit(limit).Scan(result)
	return
}

func (d dictionaryGroupItemDo) Scan(result interface{}) (err error) {
	return d.DO.Scan(result)
}

func (d dictionaryGroupItemDo) Delete(models ...*models.DictionaryGroupItem) (result gen.ResultInfo, err error) {
	return d.DO.Delete(models)
}

func (d *dictionaryGroupItemDo) withDO(do gen.Dao) *dictionaryGroupItemDo {
	d.DO = *do.(*gen.DO)
	return d
}
